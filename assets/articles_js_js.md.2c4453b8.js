import{_ as s,o as a,c as l,Q as o}from"./chunks/framework.d7a29f29.js";const E=JSON.parse('{"title":"JS","description":"","frontmatter":{},"headers":[],"relativePath":"articles/js/js.md","filePath":"articles/js/js.md"}'),n={name:"articles/js/js.md"},e=o(`<h1 id="js" tabindex="-1">JS <a class="header-anchor" href="#js" aria-label="Permalink to &quot;JS&quot;">​</a></h1><h2 id="js数据检测方法" tabindex="-1">JS数据检测方法 <a class="header-anchor" href="#js数据检测方法" aria-label="Permalink to &quot;JS数据检测方法&quot;">​</a></h2><p><code>Object.prototype.toString.call(&#39;str&#39;)</code></p><h2 id="判断数组的方法" tabindex="-1">判断数组的方法 <a class="header-anchor" href="#判断数组的方法" aria-label="Permalink to &quot;判断数组的方法&quot;">​</a></h2><ul><li>Object.prototype.toString.call()</li><li>Array.isArray()</li></ul><h2 id="null和undefined的区别" tabindex="-1">null和undefined的区别 <a class="header-anchor" href="#null和undefined的区别" aria-label="Permalink to &quot;null和undefined的区别&quot;">​</a></h2><ul><li>他们都是基础类型，都只有一个值</li><li>undefined是未定义，null是空对象，都可以做非空判断</li><li>null一般是后端的初始值</li></ul><h2 id="this" tabindex="-1">this <a class="header-anchor" href="#this" aria-label="Permalink to &quot;this&quot;">​</a></h2><p>this是一个在运行时才进行绑定的引用，在不同的情况下会被绑定不同的对象</p><h2 id="this绑定的指向" tabindex="-1">this绑定的指向 <a class="header-anchor" href="#this绑定的指向" aria-label="Permalink to &quot;this绑定的指向&quot;">​</a></h2><ul><li>函数调用的时候指向全局window</li><li>方法调用的时候，指向这个对象</li><li>构建器调用的时候，指向这个新创建的对象</li><li>apply,call 调用的时候指向了传参的第一个this绑定的对象</li><li>bind 调用的时候传入一个对象，这个this指向这个对象</li><li>箭头函数this指向他外层作用域的this</li></ul><h2 id="map和object的区别" tabindex="-1">Map和Object的区别 <a class="header-anchor" href="#map和object的区别" aria-label="Permalink to &quot;Map和Object的区别&quot;">​</a></h2><ul><li>Object的键值只能是String和symbol,Map可以是很多</li><li>Map的键是有序的，Object是无序的</li><li>Map的个数可以通过size获取</li></ul><h2 id="json-stringify深拷贝的缺点" tabindex="-1">JSON.stringify深拷贝的缺点 <a class="header-anchor" href="#json-stringify深拷贝的缺点" aria-label="Permalink to &quot;JSON.stringify深拷贝的缺点&quot;">​</a></h2><ul><li>如果obj里面有时间对象，时间对象要变成字符串</li><li>如果obj里面有函数或者undefined，会直接被丢掉</li></ul><h2 id="闭包" tabindex="-1">闭包 <a class="header-anchor" href="#闭包" aria-label="Permalink to &quot;闭包&quot;">​</a></h2><ul><li>定义：函数执行的时候回产生一个私有上下文，这个上下文能保护里面使用的变量不受外界干扰，如果这个上下文里面的变量被外部引用，这里面的就不会释放，闭包是一个保存状态和私有变量的机制</li></ul><h2 id="闭包使用场景" tabindex="-1">闭包使用场景 <a class="header-anchor" href="#闭包使用场景" aria-label="Permalink to &quot;闭包使用场景&quot;">​</a></h2><ul><li>返回函数</li><li>节流防抖</li><li>回调函数</li><li>hooks</li><li>函数柯里化</li></ul><h2 id="执行上下文的类型" tabindex="-1">执行上下文的类型 <a class="header-anchor" href="#执行上下文的类型" aria-label="Permalink to &quot;执行上下文的类型&quot;">​</a></h2><ol><li>全局执行上下文 任何不在函数内部的都是全局执行上下文，它首先会创建一个全局的window对象，并且设置this的值等于这个全局对象，一个程序中只有一个全局执行上下文</li><li>函数执行上下文 当一个函数被调用时，就会为该函数创建一个新的执行上下文，函数的上下文可以有任意多个</li></ol><h2 id="作用域" tabindex="-1">作用域 <a class="header-anchor" href="#作用域" aria-label="Permalink to &quot;作用域&quot;">​</a></h2><p>变量的有限范围</p><ul><li>1.全局作用域 <ul><li>全局作用域下声明的变量叫全局变量</li><li>全局作用域无法访问局部作用域中的变量</li></ul></li><li>2.函数作用域 <ul><li>调用函数时会创建函数作用域，函数执行完毕以后，作用域销毁。每调用一次函数就会建一个新的函数作用域，他们之间是相互独立的。</li><li>在函数作用域中可以访问全局变量，在函数的外面无法访问函数内的变量。</li><li>当在函数作用域操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用，如果没有就向上一作用域中寻找，直到找到全局作用域，如果全局作用域中仍然没有找到，则会报错。</li></ul></li><li>3.块级作用域 <ul><li>在ES6中引入的作用域，{}中使用的const和let外部环境访问不到</li></ul></li><li>4.词法作用域 <ul><li>词法作用域是静态的作用域，无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由<strong>函数被声明时所处的位置</strong>决定。</li><li>词法作用域就是你在写代码的时候就已经决定了变量的作用域</li></ul></li></ul><h2 id="执行上下文和作用域的区别" tabindex="-1">执行上下文和作用域的区别 <a class="header-anchor" href="#执行上下文和作用域的区别" aria-label="Permalink to &quot;执行上下文和作用域的区别&quot;">​</a></h2><p>执行上下文在运行时确定，随时可能改变。作用域在定义时就确定，并且不会改变</p><h2 id="原型和原型链" tabindex="-1">原型和原型链 <a class="header-anchor" href="#原型和原型链" aria-label="Permalink to &quot;原型和原型链&quot;">​</a></h2><ol><li><code>prototype</code>是显示原型，是构造函数的属性</li><li><code>__proto__</code> 是隐式原型，是实例的属性</li></ol><p>构造函数的<code>prototype</code>和实例的<code>__proto__</code>指向同一个对象，这个对象叫做原型对象</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Fn</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.name </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;呵呵&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> fn </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Fn</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(fn.</span><span style="color:#79B8FF;">__proto__</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">Fn</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">prototype</span><span style="color:#E1E4E8;">) </span><span style="color:#6A737D;">// true</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Fn</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.name </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;呵呵&#39;</span></span>
<span class="line"><span style="color:#24292E;">};</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> fn </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Fn</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(fn.</span><span style="color:#005CC5;">__proto__</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">Fn</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">prototype</span><span style="color:#24292E;">) </span><span style="color:#6A737D;">// true</span></span></code></pre></div><p>constructor是原型对象里面的一个熟悉，指向这个函数 <code>Fn.prototype.constructor == Fn</code></p><ul><li><code>函数</code>是<code>Function构造函数</code>的实例</li><li><code>对象</code>是<code>Object构造函数</code>的实例</li><li><code>Function构造函数</code>和<code>Object构造函数</code>他们是都是<code>Function构造函数</code>的实例</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">Function</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">prototype</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> Object.</span><span style="color:#79B8FF;">__proto__</span><span style="color:#E1E4E8;">) </span><span style="color:#6A737D;">// true </span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">Function</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">prototype</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> Function.</span><span style="color:#79B8FF;">__proto__</span><span style="color:#E1E4E8;">) </span><span style="color:#6A737D;">// true</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">Function</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">prototype</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> Object.</span><span style="color:#005CC5;">__proto__</span><span style="color:#24292E;">) </span><span style="color:#6A737D;">// true </span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">Function</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">prototype</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> Function.</span><span style="color:#005CC5;">__proto__</span><span style="color:#24292E;">) </span><span style="color:#6A737D;">// true</span></span></code></pre></div><p>原型链就是<code>__proto__</code>的路径，所有对象的原型链的结尾都是<code>Object.prototype</code>,<code>Object.prototype</code>的<code>__proto__</code>最后指向<code>null</code></p><p>所以继承的主要方式就是吧这个构造函数的原型<code>prototype</code>指向一个继承的实例</p><h2 id="promise" tabindex="-1">Promise <a class="header-anchor" href="#promise" aria-label="Permalink to &quot;Promise&quot;">​</a></h2><p>Promise是一种异步编程的解决方案，主要是用来解决回调地狱</p><ul><li>Promise是立即执行的</li><li>Promise的状态是不可修改的</li><li>Promise是可以链式调用的</li></ul><h2 id="async-await" tabindex="-1">async/await <a class="header-anchor" href="#async-await" aria-label="Permalink to &quot;async/await&quot;">​</a></h2><p>同步写法来执行异步代码，是Promise+generator的语法糖</p><h2 id="js同步和异步" tabindex="-1">JS同步和异步 <a class="header-anchor" href="#js同步和异步" aria-label="Permalink to &quot;JS同步和异步&quot;">​</a></h2><p>js是单线程的，同步代码按顺序执行，异步代码进异步队列，根据eventloop进行执行</p><h2 id="宏任务和微任务" tabindex="-1">宏任务和微任务 <a class="header-anchor" href="#宏任务和微任务" aria-label="Permalink to &quot;宏任务和微任务&quot;">​</a></h2><ul><li>宏任务：<code>&lt;script&gt;</code>代码段,setTimeout,setInterval,requestAnimationFrame</li><li>微任务：Promise,nextTick,</li></ul><p>先执行微任务队里里面的任务，之后再执行宏任务的队列中的任务·</p><h2 id="箭头函数" tabindex="-1">箭头函数 <a class="header-anchor" href="#箭头函数" aria-label="Permalink to &quot;箭头函数&quot;">​</a></h2><ul><li>箭头函数不能用于构造函数</li><li>箭头函数没有自己的this，他的this是他外层作用域的this</li><li>箭头函数没有原型对象</li></ul><h2 id="commonjs-和-es6-module的区别" tabindex="-1">Commonjs 和 ES6 Module的区别 <a class="header-anchor" href="#commonjs-和-es6-module的区别" aria-label="Permalink to &quot;Commonjs 和 ES6 Module的区别&quot;">​</a></h2><ul><li>Commonjs是拷贝输出，ES6模块化是引用输出</li><li>Commonjs是运行时加载，ES6模块化是编译时输出接口</li><li>Commonjs是单个值导出，ES6模块化可以多个值导出</li><li>Commonjs是动态语法可写在函数体中，ES6模块化静态语法只能写在顶层</li></ul>`,49),t=[e];function p(i,r,c,d,h,y){return a(),l("div",null,t)}const m=s(n,[["render",p]]);export{E as __pageData,m as default};
